/*
PROCEDURE:		[Audit].[usp_SetupServerDDLAudit]
AUTHOR:			Derik Hammer
CREATION DATE:	10/1/2012
DESCRIPTION:	This procedure will perform an Incremental install or repair of the Server level DDL auditing feature.
PARAMETERS:		

*/
/*
CHANGE HISTORY:

** Derik Hammer ** 10/24/2012 --	Removed references to the 'Utility - Audit - Server DDL' job which is no longer
									part of this design.

** Derik Hammer ** 02/19/2013 --	Removed the create table statement for ServerDDL and moved the table into a permanent
									table for the database project.

** Derik Hammer ** 09/16/2013 --	Modified the trigger catch to raise a severity 10 error rather than return a SELECT result set.

*/
CREATE PROCEDURE [Audit].[usp_SetupServerDDLAudit]
AS
	SET NOCOUNT ON;

	DECLARE @ServerDDLTriggerDefinition VARCHAR(8000)
	DECLARE @DatabaseUserPermissions VARCHAR(8000)
	DECLARE @ServiceAccountName SYSNAME
	DECLARE @CommandType VARCHAR(6)
	DECLARE @AgentJobID UNIQUEIDENTIFIER
	DECLARE @LogEntry VARCHAR(8000)

	BEGIN TRANSACTION

	--Identify which service account to use. Pick the lowest environment account found.
	IF EXISTS (	SELECT InformationDetailID 
				FROM [Configuration].[InformationDetails] InfoD
				INNER JOIN [Lookup].[Features] F ON InfoD.FeatureID = F.FeatureID
				INNER JOIN [Lookup].[InformationTypes] InfoT ON InfoT.InformationTypeID = InfoD.InformationTypeID
				WHERE F.FeatureName = 'Utility'
					AND InfoT.InfoTypeDesc = 'ServiceAccount' )
	BEGIN
		SELECT @ServiceAccountName = InfoD.Detail
		FROM [Configuration].[InformationDetails] InfoD
		INNER JOIN [Lookup].[Features] F ON InfoD.FeatureID = F.FeatureID
		INNER JOIN [Lookup].[InformationTypes] InfoT ON InfoT.InformationTypeID = InfoD.InformationTypeID
		WHERE F.FeatureName = 'Utility'
			AND InfoT.InfoTypeDesc = 'ServiceAccount'
	END
	ELSE
	BEGIN
		RAISERROR('Appropriate service account not present in the [Configuration].[InformationDetails] table.',16,1)
	END

	--
	-- Drop and Create Utility - Audit - RESTORE DATABASE job to ensure it hasn't been altered.
	--

	IF EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'Utility - Audit - RESTORE DATABASE')
	BEGIN
		SELECT @AgentJobID=job_id FROM msdb.dbo.sysjobs_view WHERE name = N'Utility - Audit - RESTORE DATABASE'
		EXEC msdb.dbo.sp_delete_job @job_id=@AgentJobID, @delete_unused_schedule=1

		EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'Dropped SQL Agent Job: Utility - Audit - RESTORE DATABASE', @LogMode = 'VERBOSE'
	END
	  
	BEGIN TRANSACTION
	DECLARE @ReturnCode INT
	SELECT @ReturnCode = 0

	IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance Utility' AND category_class=1)
	BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Database Maintenance Utility'
	EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'Add SQL Agent Job Category: Database Maintenance Utility', @LogMode = 'VERBOSE'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

	END

	DECLARE @jobId BINARY(16)
	EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'Utility - Audit - RESTORE DATABASE', 
			@enabled=1, 
			@notify_level_eventlog=0, 
			@notify_level_email=0, 
			@notify_level_netsend=0, 
			@notify_level_page=0, 
			@delete_level=0, 
			@description=N'Copies new RESTORE DATABASE auditing from msdb.dbo.restorehistory to Utility.Audit.ServerDDL every minute', 
			@category_name=N'Database Maintenance Utility', 
			@owner_login_name=@ServiceAccountName, @job_id = @jobId OUTPUT
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	/****** Object:  Step [Audit RESTORE DATABASE commands]    Script Date: 05/26/2010 15:11:10 ******/
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Audit RESTORE DATABASE commands', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_success_step_id=0, 
			@on_fail_action=2, 
			@on_fail_step_id=0, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'--
-- SQL 2008 DDL Auditing Solution
--
-- Install Audit RESTORE DATABASE job which detects database restores and copies the details from
-- msdb to Utility.Audit.ServerDDL
--
-- DO NOT EDIT THIS JOB DIRECTLY - edit script install_on_all_db.sql
--

insert  Utility.Audit.ServerDDL
	(
	AuditDate, LoginName, EventType,
	ServerName, DatabaseName, SchemaName, 
	ObjectName, TSQLCommand, XMLEventData
	)
	select  restore_date AuditDate,
			user_name LoginName,
			''RESTORE_DATABASE'' EventType,
			@@servername ServerName,
			destination_database_name DatabaseName,
			null SchemaName,
			null ObjectName,
			''RESTORE DATABASE '' + destination_database_name + 
			'', backup_set_id = '' + convert(varchar, backup_set_id) +
			'', restore_type = '' + restore_type + 
			'', replace = '' + convert(varchar, replace) + 
			'', recovery = '' + convert(varchar, recovery),
			''Generated by SQL Agent job Audit RESTORE DATABASE'' XMLEventData
			from  msdb.dbo.restorehistory
			where restore_date > isnull((select max(AuditDate) from Utility.Audit.ServerDDL where EventType = ''RESTORE_DATABASE''), ''1900-Jan-01'')
       
	', 
			@database_name=N'master', 
			@flags=4
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Every 1 minute', 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=4, 
			@freq_subday_interval=1, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=20100521, 
			@active_end_date=99991231, 
			@active_start_time=0, 
			@active_end_time=235959
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	COMMIT TRANSACTION
	EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'Created SQL Agent Job: Utility - Audit - RESTORE DATABASE', @LogMode = 'VERBOSE'  
	GOTO EndSave
	QuitWithRollback:
		IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
	EndSave:

	if not exists (select * from sys.database_principals where name = @ServiceAccountName)
	BEGIN
		SET @DatabaseUserPermissions = 'create user [' + @ServiceAccountName + '] for login [' + @ServiceAccountName + '] WITH DEFAULT_SCHEMA = dbo;
		  grant connect on database::[Utility] to [' + @ServiceAccountName + '];
		  grant insert, select on [Audit].[ServerDDL] to [' + @ServiceAccountName + '];'

		EXEC (@DatabaseUserPermissions)

		SET @LogEntry = 'create user [' + @ServiceAccountName + '] for login [' + @ServiceAccountName + '] WITH DEFAULT_SCHEMA = dbo;'
		EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE'  
		SET @LogEntry = 'grant connect on database::[Utility] to [' + @ServiceAccountName + '];'
		EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE'  
		SET @LogEntry = 'grant insert, select on [Audit].[ServerDDL] to [' + @ServiceAccountName + '];'
		EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE'  
	end
	else begin
	  print 'Skip create [' + @ServiceAccountName + '] user for [Utility]'
	end

	--
	-- Create server audit trigger in Utility
	--
	if exists (select * from master.sys.server_triggers where parent_class_desc = 'SERVER' and name = N'ServerAuditTrigger')
	begin
	  SET @CommandType = 'ALTER'
  	  print 'Alter the ServerAuditTrigger to ensure it has not been altered.';
	  disable trigger ServerAuditTrigger on all SERVER
		EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'disable trigger ServerAuditTrigger on all SERVER', @LogMode = 'VERBOSE'     
	end
	else begin
	  SET @CommandType = 'CREATE'
	  print 'Skip disable and drop ServerAuditTrigger'
	end
	
	SET @ServerDDLTriggerDefinition = @CommandType + ' TRIGGER ServerAuditTrigger
	ON ALL SERVER
	-- Audit server level and database level into Utility.Audit.ServerDDL
	WITH EXECUTE AS ''' + @ServiceAccountName + '''
	FOR DDL_EVENTS
	AS 
	BEGIN
	  --
	  -- SQL 2008 DDL Auditing Solution
	  --
	  -- Server level DDL audit
	  --
  
	  set nocount on 
  
	  -- Needed for xml data type
	  set ansi_padding on
	  set ansi_warnings on
	  set arithabort on
	  set concat_null_yields_null on
	  set numeric_roundabort off
   
	  declare @EventData xml,
			  @EventType sysname,
			  @TSQLCommand varchar(max)
    
	  set @EventData = EventData()
  
		-- debug
		-- select @EventData

	  set @EventType = @EventData.value(''data(/EVENT_INSTANCE/EventType)[1]'', ''sysname'')
	  set @TSQLCommand = @EventData.value(''data(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]'', ''varchar(max)'')
  
		BEGIN TRY
		  insert Utility.Audit.ServerDDL
		  (
			AuditDate, LoginName, EventType, ServerName, DatabaseName, SchemaName, ObjectName, TSQLCommand, XMLEventData
		  )
		  select 
			getdate(),
			@EventData.value(''data(/EVENT_INSTANCE/LoginName)[1]'', ''sysname''),
			@EventType,
			@EventData.value(''data(/EVENT_INSTANCE/ServerName)[1]'', ''sysname''),
			@EventData.value(''data(/EVENT_INSTANCE/DatabaseName)[1]'', ''sysname''),
			coalesce
			( @EventData.value(''data(/EVENT_INSTANCE/SchemaName)[1]'', ''sysname''),
			  @EventData.value(''data(/EVENT_INSTANCE/DefaultSchema)[1]'', ''sysname'')
			), 
			@EventData.value(''data(/EVENT_INSTANCE/ObjectName)[1]'', ''sysname''), 
			@TSQLCommand,
			@EventData
		END TRY
		BEGIN CATCH
			DECLARE @msg NVARCHAR(4000)
			SELECT @msg = ''Error inserting into Utility.Audit.ServerDDL. ERROR_NUMBER() = '' + CAST(ERROR_NUMBER() AS NVARCHAR(10)) + 
				'', ERROR_MESSAGE() = '' + CAST(ERROR_MESSAGE() AS NVARCHAR(3000))
			RAISERROR(10,1,@msg)
		END CATCH;
	END'

	EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @ServerDDLTriggerDefinition, @LogMode = 'VERBOSE'     
	EXEC (@ServerDDLTriggerDefinition)

	--
	-- Allow Utility service account to run job "Utility - Audit - RESTORE DATABASE" expediently
	--
	if not exists
	(
	  select mpl.name
	  from msdb.sys.database_principals rol
	  join msdb.sys.database_role_members mrs
	  on mrs.role_principal_id = rol.principal_id
	  join msdb.sys.database_principals mpl
	  on mpl.principal_id = mrs.member_principal_id
	  where rol.name = 'SQLAgentOperatorRole'
	  and mpl.type = 'S'
	  and mpl.name = @ServiceAccountName
	)
	BEGIN
	  --Create user
	  if not exists (select * from msdb.sys.database_principals where name = @ServiceAccountName)
		BEGIN
		  print 'Create user [' + @ServiceAccountName + '] in [msdb]'
		  SET @DatabaseUserPermissions = 'USE msdb; create user [' + @ServiceAccountName + '] for login [' + @ServiceAccountName + '] WITH DEFAULT_SCHEMA = dbo;
			grant connect on database::[msdb] to [' + @ServiceAccountName + '];'

			SET @LogEntry = 'USE msdb; create user [' + @ServiceAccountName + '] for login [' + @ServiceAccountName + '] WITH DEFAULT_SCHEMA = dbo;'
			EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE' 
			SET @LogEntry = 'grant connect on database::[msdb] to [' + @ServiceAccountName + '];'
			EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE' 

		  EXEC (@DatabaseUserPermissions)
		end
		else begin
		  print 'Skip create [' + @ServiceAccountName + '] user for [msdb]'
		END
        
	  --Grant msdb SQLAgentOperatorRole
	  IF NOT EXISTS (SELECT name 
						FROM msdb.sys.database_principals dbP
						INNER JOIN msdb.sys.database_role_members drM ON dbP.principal_id = drM.member_principal_id
						WHERE name = 'LIBERTY\DevUtility'
							AND role_principal_id = (SELECT DISTINCT principal_id FROM msdb.sys.database_principals WHERE name = 'SQLAgentOperatorRole'))      
	  BEGIN
		  print 'Add ' + @ServiceAccountName + ' to role SQLAgentOperatorRole'
		  exec msdb..sp_addrolemember @rolename = N'SQLAgentOperatorRole', @membername = @ServiceAccountName

		  SET @LogEntry = 'exec msdb..sp_addrolemember @rolename = N''SQLAgentOperatorRole'', @membername = ' + @ServiceAccountName
		  EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = @LogEntry, @LogMode = 'VERBOSE'
	  END
	end
	else begin
	  print 'Skip add ' + @ServiceAccountName + ' to role SQLAgentOperatorRole'
	end

	EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'Server level DDL Auditing established via stored procedure - [Audit].[usp_SetupServerDDLAudit]', @LogMode = 'LIMITED'

	--
	-- Make sure the trigger is enabled
	-- Everything past here will now be audited at the server level
	--
	;enable trigger ServerAuditTrigger on all server;
	EXEC Logging.usp_InsertLogEntry @Feature = 'Audit',	@TextEntry = 'enable trigger ServerAuditTrigger on all server;', @LogMode = 'VERBOSE'

	--
	-- Ensure there is an Audit.Options record to indicate record retention.
	-- Default will be NULL for no purging.
	--
	IF NOT EXISTS (SELECT OptionID FROM [Audit].[Options])
	BEGIN
		INSERT INTO [Audit].[Options] ( [PurgeValue], [PurgeTypeID] ) VALUES (NULL, NULL);
	END


	COMMIT
